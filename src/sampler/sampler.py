"""Module for the abstract Sampler class."""
from base.exceptions import ConfigurationError
from abc import ABCMeta, abstractmethod
import numpy as np
import os


class Sampler(metaclass=ABCMeta):
    """
    Abstract class for taking observations of the state of the system.
    """

    def __init__(self, output_directory: str, **kwargs):
        """
        The constructor of the Sampler class.

        This class is designed for cooperative inheritance, meaning that it passes through all unused kwargs in the
        init to the next class in the MRO via super.

        Parameters
        ----------
        output_directory : str
            The name of the directory into which the sample file is written at the end of the run.
        kwargs : Any
            Additional kwargs which are passed to the __init__ method of the next class in the MRO.

        Raises
        ------
        base.exceptions.ConfigurationError
            If type(output_directory) is not str.
        """
        super().__init__(**kwargs)
        if type(output_directory) is not str:
            raise ConfigurationError(f"Give a value of type str as output_directory in {self.__class__.__name__}.")
        self._output_directory = output_directory
        os.makedirs(self._output_directory, exist_ok=True)

    @abstractmethod
    def initialise_sample_array(self, total_number_of_iterations):
        """
        Generate array that stores the sample.

        Parameters
        ----------
        total_number_of_iterations : int
            The total number of iterations of the Markov chain.

        Returns
        -------
        numpy.ndarray
            Numpy array of zeros of the required structure.
        """
        raise NotImplementedError

    @abstractmethod
    def get_observation(self, momenta, positions, potential):
        """
        Returns an observation of the system for the given particle momenta and positions.

        Parameters
        ----------
        momenta : None or numpy.ndarray
            None or a two-dimensional numpy array of size (number_of_particles, dimensionality_of_particle_space); each
            element is a float and represents one Cartesian component of the momentum of a single particle.
        positions : numpy.ndarray
            A two-dimensional numpy array of size (number_of_particles, dimensionality_of_particle_space); each element
            is a float and represents one Cartesian component of the position of a single particle. For Bayesian
            models, the entire positions array corresponds to the parameter; for the Ginzburg-Landau potential on a
            lattice, the entire positions array corresponds to the entire array of superconducting phase.
        potential : float or potential.potential.Potential
            If a float, the current value of the potential; otherwise, an instance of the chosen child class of
            potential.potential.Potential.

        Returns
        -------
        numpy.ndarray
            The observation.
        """
        raise NotImplementedError

    @abstractmethod
    def output_sample(self, sample, temperature_index):
        """
        Following completion of the Markov chain, print the sample to the output file.

        Parameters
        ----------
        sample : numpy.ndarray
            The sample generated by the Markov chain.
        temperature_index : int
            The index of the iteration through the list sampling temperatures.
        """
        raise NotImplementedError

    @abstractmethod
    def get_sample(self, temperature_index):
        """
        In order to analyse the Markov chain in an external program, read the sample from the output file.

        Parameters
        ----------
        temperature_index : int
            The index of the iteration through the list sampling temperatures.

        Returns
        ----------
        numpy.ndarray
            The sample generated by the Markov chain.
        """
        raise NotImplementedError

    def _write_sample_to_file(self, sample, sample_file_string):
        np.save(os.path.join(os.getcwd(), self._output_directory, sample_file_string),
                np.reshape(sample, (sample.shape[0], -1)))

    def _read_sample_from_file(self, sample_file_string):
        return np.load(self._output_directory + '/' + sample_file_string)
