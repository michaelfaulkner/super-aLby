"""This module contains methods that convert samples generated by super-aLby into sample observables."""
import numpy as np


"""Methods to get base samples"""


def get_mean_particle_separation(sample_directory, temperature, temperature_index, number_of_particles,
                                 number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the mean particle separation.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the mean particle separation.  A one-dimensional numpy array of maximum length
        number_of_observations + number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial
        system state) but the length is shortened if number_of_equilibration_iterations and/or thinning_level is not
        None.  The nth element is a float corresponding to the mean particle separation measured at observation n.
    """
    return get_reduced_sample(np.load(
        f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_mean_particle_separation.npy").flatten(),
                              number_of_equilibration_iterations, thinning_level)


def get_mean_positions(sample_directory, temperature, temperature_index, number_of_particles,
                       number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the mean particle positions (where each position may be corrected for periodic boundaries).

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the mean particle positions.  A two-dimensional numpy array of shape
        (L, dimensionality_of_particle_space) where the maximum value of L is number_of_observations +
        number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial system state) but L is
        shortened if number_of_equilibration_iterations and/or thinning_level is not None.  The nth element is a
        dimensionality_of_particle_space-length numpy array corresponding to the observation n; the ith element of each
        sub-array is the ith Cartesian component the mean particle position at observation n.
    """
    return get_reduced_sample(
        np.load(f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_mean_positions.npy"),
        number_of_equilibration_iterations, thinning_level)


def get_momenta(sample_directory, temperature, temperature_index, number_of_particles,
                number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of particle momenta.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of particle momenta.  A three-dimensional numpy array of shape (L, number_of_particles,
        dimensionality_of_particle_space) where the maximum value of L is number_of_observations +
        number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial system state) but L is
        shortened if number_of_equilibration_iterations and/or thinning_level is not None.  Each element is a
        float corresponding to one of the Cartesian components of the momentum of some particle.
    """
    return get_reduced_sample(np.load(f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_momenta.npy"),
                              number_of_equilibration_iterations, thinning_level)


def get_particle_separations(sample_directory, temperature, temperature_index, number_of_particles,
                             number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the minimum (if on the torus) particle separation distances.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of particle separations.  A two-dimensional numpy array of shape (L, number_of_particle_pairs)
        where the maximum value of L is number_of_observations + number_of_equilibration_iterations + 1 (the 1 is
        for the observation of the initial system state) but L is shortened if number_of_equilibration_iterations
        and/or thinning_level is not None.  Each element is a float corresponding to single minimum particle-pair
        separation.
    """
    return get_reduced_sample(np.load(
        f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_particle_separations.npy"),
        number_of_equilibration_iterations, thinning_level)


def get_positions(sample_directory, temperature, temperature_index, number_of_particles,
                  number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of particle positions.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of particle positions.  A three-dimensional numpy array of shape (L, number_of_particles,
        dimensionality_of_particle_space) where the maximum value of L is number_of_observations +
        number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial system state) but L is
        shortened if number_of_equilibration_iterations and/or thinning_level is not None.  Each element is a
        float corresponding to one of the Cartesian components of the position of some particle.
    """
    return get_reduced_sample(
        np.load(f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_positions.npy"),
        number_of_equilibration_iterations, thinning_level)


def get_potential(sample_directory, temperature, temperature_index, number_of_particles,
                  number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the potential sample.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The potential sample.  A one-dimensional numpy array of maximum length number_of_observations +
        number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial system state) but the
        length is shortened if number_of_equilibration_iterations and/or thinning_level is not None.  The nth element
        is a float corresponding to the potential measured at observation n.
    """
    return get_reduced_sample(np.load(
        f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_potential.npy").flatten(),
                              number_of_equilibration_iterations, thinning_level)


def get_single_particle_separation(sample_directory, temperature, temperature_index, number_of_particles,
                                   number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the minimum (if on the torus) separation distance between the zeroth and first particles.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the particle separation.  A two-dimensional numpy array of shape
        (L, number_of_particle_pairs) where the maximum value of L is number_of_observations +
        number_of_equilibration_iterations + 1 (the 1 is for the observation of the initial system state) but L is
        shortened if number_of_equilibration_iterations and/or thinning_level is not None.  Each element is a float
        corresponding to single minimum particle-pair separation.
    """
    return get_reduced_sample(np.load(
        f"{sample_directory}/temperature_{temperature_index:02d}_sample_of_single_particle_separation.npy"),
        number_of_equilibration_iterations, thinning_level)


"""Methods to get samples of observations that are functions of the observations corresponding ot the base samples"""


def get_specific_heat(sample_directory, temperature, temperature_index, number_of_particles,
                      number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the specific heat
    C_V(x; temperature, number_of_particles) = [U(x; temperature, number_of_particles) -
    E[U(x; temperature, number_of_particles)]] ** 2 / temperature ** 2, with x the particle positions at the time of
    observation and U(x; temperature, number_of_particles) the system potential.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s) and Metropolis acceptance rate(s) (plurals refer to the
        option of multiple repeated simulations).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the specific heat per particle.  A one-dimensional numpy array of length number_of_observations.
        The nth element is a float corresponding to the specific heat measured at observation n.
    """
    potential_sample = get_potential(sample_directory, temperature, temperature_index, number_of_particles,
                                     number_of_equilibration_iterations, thinning_level)
    return (potential_sample - np.mean(potential_sample)) ** 2 / temperature ** 2


def get_magnetic_density(sample_directory, temperature, temperature_index, number_of_particles,
                         number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the magnetic density m = sum_i x_i / number_of_particles of the Ising model, where x_i is the
    position of particle i.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s) and Metropolis acceptance rate(s) (plurals refer to the
        option of multiple repeated simulations).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the magnetic density.  A one-dimensional numpy array of length number_of_observations.  The nth
        element is a float corresponding to the magnetic density measured at observation n.
    """
    return get_mean_positions(sample_directory, temperature, temperature_index, number_of_particles,
                              number_of_equilibration_iterations, thinning_level).flatten()


def get_magnetic_susceptibility(sample_directory, temperature, temperature_index, number_of_particles,
                                number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the magnetic susceptibility chi(x; temperature, number_of_particles) per particle, where
    E[chi(x; temperature, number_of_particles)] := \nabla_h E[M] = beta N^2 Var[m], M = number_of_particles * m is the
    magnetisation, m = sum_i x_i / number_of_particles is the magnetic density and x_i is the position of particle i.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s) and Metropolis acceptance rate(s) (plurals refer to the
        option of multiple repeated simulations).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the magnetic susceptibility per particle.  A one-dimensional numpy array of length
        number_of_observations.  The nth element is a float corresponding to the magnetic susceptibility measured at
        observation n.
    """
    magnetic_density_sample = get_magnetic_density(sample_directory, temperature, temperature_index,
                                                   number_of_particles, number_of_equilibration_iterations,
                                                   thinning_level)
    return number_of_particles * (magnetic_density_sample - np.mean(magnetic_density_sample)) ** 2 / temperature


def get_magnetic_norm_density(sample_directory, temperature, temperature_index, number_of_particles,
                              number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the magnetic-norm density ||m|| of the Ising model, where m = sum_i x_i / number_of_particles
    is the magnetic density and x_i is the position of particle i.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s) and Metropolis acceptance rate(s) (plurals refer to the
        option of multiple repeated simulations).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the magnetic-norm density.  A one-dimensional numpy array of length number_of_observations.  The
        nth element is a float corresponding to the magnetic density measured at observation n.
    """
    return np.abs(get_magnetic_density(sample_directory, temperature, temperature_index, number_of_particles,
                                       number_of_equilibration_iterations, thinning_level))


def get_magnetic_norm_susceptibility(sample_directory, temperature, temperature_index, number_of_particles,
                                     number_of_equilibration_iterations=None, thinning_level=None):
    """
    Returns the sample of the magnetic-norm susceptibility chi_{||m||}(x; temperature, number_of_particles) per
    particle, where E[chi_{||m||}(x; temperature, number_of_particles)] := beta N^2 Var[||m||] where
    m = sum_i x_i / number_of_particles is the magnetic density and x_i is the position of particle i.

    See the docstring of get_magnetic_susceptibility() for an understanding of the origin of this definition.

    Parameters
    ----------
    sample_directory : str
        The location of the directory containing the sample(s) and Metropolis acceptance rate(s) (plurals refer to the
        option of multiple repeated simulations).
    temperature : float
        The sampling temperature.
    temperature_index : int
        The index of the current sampling temperature within the configuration file.
    number_of_particles : int
        The total number of particles.
    number_of_equilibration_iterations : None or int, optional
        The total number of equilibration iterations of the Markov process.  If None, the entire sample is returned.
    thinning_level : None or int, optional
        1 - the number of observations to be discarded between retained observations of the thinning process.  If None,
        all observations are retained.

    Returns
    -------
    numpy.ndarray
        The sample of the magnetic-norm susceptibility per particle.  A one-dimensional numpy array of length
        number_of_observations.  The nth element is a float corresponding to the magnetic susceptibility measured at
        observation n.
    """
    magnetic_norm_density_sample = get_magnetic_norm_density(sample_directory, temperature, temperature_index,
                                                             number_of_particles, number_of_equilibration_iterations,
                                                             thinning_level)
    return number_of_particles * (
            magnetic_norm_density_sample - np.mean(magnetic_norm_density_sample)) ** 2 / temperature


"""helper methods"""


def get_reduced_sample(entire_sample, number_of_equilibration_iterations=None, thinning_level=None):
    if number_of_equilibration_iterations is None:
        if thinning_level is None:
            return entire_sample
        return entire_sample[::thinning_level]
    if thinning_level is None:
        return entire_sample[number_of_equilibration_iterations + 1:]
    return entire_sample[number_of_equilibration_iterations + 1::thinning_level]
